<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Riconciliazione | React</title>
  <meta name="viewport" content="width=device-width">
  <meta property="og:title" content="Riconciliazione | React">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://facebook.github.io/react/docs/reconciliation-it-IT.html">
  <meta property="og:image" content="https://facebook.github.io/react/img/logo_og.png">
  <meta property="og:description" content="A JavaScript library for building user interfaces">
  <meta property="fb:app_id" content="623268441017527">

  <link rel="shortcut icon" href="/react/favicon.ico">
  <link rel="alternate" type="application/rss+xml" title="React" href="https://facebook.github.io/react/feed.xml">

  <link rel="stylesheet" href="/react/css/syntax.css">
  <link rel="stylesheet" href="/react/css/codemirror.css">
  <link rel="stylesheet" href="/react/css/react.css">

  <script src="//use.typekit.net/vqa1hcx.js"></script>
  <script>try{Typekit.load();}catch(e){}</script>

  <!--[if lte IE 8]>
  <script src="/react/js/html5shiv.min.js"></script>
  <script src="/react/js/es5-shim.min.js"></script>
  <script src="/react/js/es5-sham.min.js"></script>
  <![endif]-->
  <script src="/react/js/codemirror.js"></script>
  <script src="/react/js/javascript.js"></script>
  <script src="/react/js/react.js"></script>
  <script src="/react/js/react-dom.js"></script>
  <script src="/react/js/babel-browser.min.js"></script>
  <script src="/react/js/live_editor.js"></script>
</head>
<body>

  <div class="container">

    <div class="nav-main">
      <div class="wrap">
        <a class="nav-home" href="/react/index.html">
          <img class="nav-logo" src="/react/img/logo.svg" width="36" height="36">
          React
        </a>
        <ul class="nav-site nav-site-internal">
          <li><a href="/react/docs/getting-started.html" class="active">Docs</a></li>
          <li><a href="/react/support.html">Support</a></li>
          <li><a href="/react/downloads.html">Download</a></li>
          <li><a href="/react/blog/">Blog</a></li>
        </ul>

        <ul class="nav-site nav-site-external">
          <li><a href="https://github.com/facebook/react">GitHub</a>
          <li><a href="https://facebook.github.io/react-native/">React Native</a>
        </ul>
      </div>
    </div>

    

    <section class="content wrap documentationContent">
  <div class="nav-docs">
  <!-- Docs Nav -->
  
    <div class="nav-docs-section">
      <h3>Quick Start</h3>
      <ul>
        
          <li>
            <a href="/react/docs/getting-started.html">Getting Started</a>
            
          </li>
        
          <li>
            <a href="/react/docs/tutorial.html">Tutorial</a>
            
          </li>
        
          <li>
            <a href="/react/docs/thinking-in-react.html">Thinking in React</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Community Resources</h3>
      <ul>
        
          <li>
            <a href="/react/docs/conferences.html">Conferences</a>
            
          </li>
        
          <li>
            <a href="/react/docs/videos.html">Videos</a>
            
          </li>
        
          <li>
            <a href="/react/docs/complementary-tools.html">Complementary Tools</a>
            
          </li>
        
          <li>
            <a href="/react/docs/examples.html">Examples</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Guides</h3>
      <ul>
        
          <li>
            <a href="/react/docs/why-react.html">Why React?</a>
            
          </li>
        
          <li>
            <a href="/react/docs/displaying-data.html">Displaying Data</a>
            
              <ul>
                
                  <li>
                    <a href="/react/docs/jsx-in-depth.html">JSX in Depth</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/jsx-spread.html">JSX Spread Attributes</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/jsx-gotchas.html">JSX Gotchas</a>
                  </li>
                
              </ul>
            
          </li>
        
          <li>
            <a href="/react/docs/interactivity-and-dynamic-uis.html">Interactivity and Dynamic UIs</a>
            
          </li>
        
          <li>
            <a href="/react/docs/multiple-components.html">Multiple Components</a>
            
          </li>
        
          <li>
            <a href="/react/docs/reusable-components.html">Reusable Components</a>
            
          </li>
        
          <li>
            <a href="/react/docs/transferring-props.html">Transferring Props</a>
            
          </li>
        
          <li>
            <a href="/react/docs/forms.html">Forms</a>
            
          </li>
        
          <li>
            <a href="/react/docs/working-with-the-browser.html">Working With the Browser</a>
            
              <ul>
                
                  <li>
                    <a href="/react/docs/more-about-refs.html">Refs to Components</a>
                  </li>
                
              </ul>
            
          </li>
        
          <li>
            <a href="/react/docs/tooling-integration.html">Tooling Integration</a>
            
          </li>
        
          <li>
            <a href="/react/docs/addons.html">Add-Ons</a>
            
              <ul>
                
                  <li>
                    <a href="/react/docs/animation.html">Animation</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/two-way-binding-helpers.html">Two-Way Binding Helpers</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/test-utils.html">Test Utilities</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/clone-with-props.html">Cloning Elements</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/create-fragment.html">Keyed Fragments</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/update.html">Immutability Helpers</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/pure-render-mixin.html">PureRenderMixin</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/perf.html">Performance Tools</a>
                  </li>
                
              </ul>
            
          </li>
        
          <li>
            <a href="/react/docs/advanced-performance.html">Advanced Performance</a>
            
          </li>
        
          <li>
            <a href="/react/docs/context.html">Context</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Reference</h3>
      <ul>
        
          <li>
            <a href="/react/docs/top-level-api.html">Top-Level API</a>
            
          </li>
        
          <li>
            <a href="/react/docs/component-api.html">Component API</a>
            
          </li>
        
          <li>
            <a href="/react/docs/component-specs.html">Component Specs and Lifecycle</a>
            
          </li>
        
          <li>
            <a href="/react/docs/tags-and-attributes.html">Supported Tags and Attributes</a>
            
          </li>
        
          <li>
            <a href="/react/docs/events.html">Event System</a>
            
          </li>
        
          <li>
            <a href="/react/docs/dom-differences.html">DOM Differences</a>
            
          </li>
        
          <li>
            <a href="/react/docs/special-non-dom-attributes.html">Special Non-DOM Attributes</a>
            
          </li>
        
          <li>
            <a href="/react/docs/reconciliation.html">Reconciliation</a>
            
          </li>
        
          <li>
            <a href="/react/docs/webcomponents.html">Web Components</a>
            
          </li>
        
          <li>
            <a href="/react/docs/glossary.html">React (Virtual) DOM Terminology</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Flux</h3>
      <ul>
        
          <li>
            <a href="https://facebook.github.io/flux/docs/overview.html">Flux Overview</a>
            
          </li>
        
          <li>
            <a href="https://facebook.github.io/flux/docs/todo-list.html">Flux TodoMVC Tutorial</a>
            
          </li>
        
      </ul>
    </div>
  

  <!-- Tips Nav -->
  
    <div class="nav-docs-section">
      <h3>Tips</h3>
      <ul>
        
          <li>
            <a href="/react/tips/introduction.html">Introduction</a>
          </li>
        
          <li>
            <a href="/react/tips/inline-styles.html">Inline Styles</a>
          </li>
        
          <li>
            <a href="/react/tips/if-else-in-JSX.html">If-Else in JSX</a>
          </li>
        
          <li>
            <a href="/react/tips/self-closing-tag.html">Self-Closing Tag</a>
          </li>
        
          <li>
            <a href="/react/tips/maximum-number-of-jsx-root-nodes.html">Maximum Number of JSX Root Nodes</a>
          </li>
        
          <li>
            <a href="/react/tips/style-props-value-px.html">Shorthand for Specifying Pixel Values in style props</a>
          </li>
        
          <li>
            <a href="/react/tips/children-props-type.html">Type of the Children props</a>
          </li>
        
          <li>
            <a href="/react/tips/controlled-input-null-value.html">Value of null for Controlled Input</a>
          </li>
        
          <li>
            <a href="/react/tips/componentWillReceiveProps-not-triggered-after-mounting.html">componentWillReceiveProps Not Triggered After Mounting</a>
          </li>
        
          <li>
            <a href="/react/tips/props-in-getInitialState-as-anti-pattern.html">Props in getInitialState Is an Anti-Pattern</a>
          </li>
        
          <li>
            <a href="/react/tips/dom-event-listeners.html">DOM Event Listeners in a Component</a>
          </li>
        
          <li>
            <a href="/react/tips/initial-ajax.html">Load Initial Data via AJAX</a>
          </li>
        
          <li>
            <a href="/react/tips/false-in-jsx.html">False in JSX</a>
          </li>
        
          <li>
            <a href="/react/tips/communicate-between-components.html">Communicate Between Components</a>
          </li>
        
          <li>
            <a href="/react/tips/expose-component-functions.html">Expose Component Functions</a>
          </li>
        
          <li>
            <a href="/react/tips/children-undefined.html">this.props.children undefined</a>
          </li>
        
          <li>
            <a href="/react/tips/use-react-with-other-libraries.html">Use React with Other Libraries</a>
          </li>
        
          <li>
            <a href="/react/tips/dangerously-set-inner-html.html">Dangerously Set innerHTML</a>
          </li>
        
      </ul>
    </div>
  
</div>


  <div class="inner-content">
    <h1>
      Riconciliazione
      <a class="edit-page-link" href="https://github.com/facebook/react/tree/master/docs/docs/ref-08-reconciliation.it-IT.md" target="_blank">Edit on GitHub</a>
    </h1>
    <div class="subHeader"></div>

    <p>La decisione chiave del design di React è fare in modo che l&#39;API sembri ripetere il rendering dell&#39;intera applicazione per ciascun aggiornamento. Ciò rende la scrittura delle applicazione molto più semplice, ma è anche una sfida incredibile per renderlo trattabile. Questo articolo spiega come siamo riusciti a trasformare, tramite potenti euristiche, un problema O(n<sup>3</sup>) in uno O(n).</p>
<h2><a class="anchor" name="motivazione"></a>Motivazione <a class="hash-link" href="#motivazione">#</a></h2>
<p>Generare il minimo numero di operazioni necessarie a trasformare un albero in un altro è un problema complesso e ben noto. Gli <a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf">algoritmi dello stato dell&#39;arte</a> hanno una complessità dell&#39;ordine di O(n<sup>3</sup>) dove n è il numero di nodi dell&#39;albero.</p>

<p>Ciò significa che visualizzare 1000 nodi richiederebbe un numero di confronti dell&#39;ordine del miliardo. Ciò è decisamente troppo costoso per il nostro caso d&#39;uso. Per mettere questo numero in prospettiva, le CPU oggi giorno eseguono approssimativamente 3 miliardi di istruzioni al secondo. Quindi anche con l&#39;implementazione più efficiente, non saremmo in grado di calcolare la differenza in meno di un secondo.</p>

<p>Dal momento che un algoritmo ottimo non è trattabile, implementiamo un algoritmo O(n) non ottimale usando euristiche basate su due assunzioni:</p>

<ol>
<li>Due componenti della stessa classe genereranno alberi simili e due componenti di classi diverse genereranno alberi diversi.</li>
<li>È possibile fornire una chiave unica per gli elementi che sia stabile durante rendering differenti.</li>
</ol>

<p>In pratica, queste assunzioni sono eccezionalmente veloci per quasi tutti i casi d&#39;uso pratici.</p>
<h2><a class="anchor" name="differenza-a-coppie"></a>Differenza a coppie <a class="hash-link" href="#differenza-a-coppie">#</a></h2>
<p>Per effettuare la differenza di due alberi, dobbiamo prima essere capaci di effettuare la differenza tra due nodi. Esistono tre diversi casi da considerare.</p>
<h3><a class="anchor" name="tipi-di-nodo-differenti"></a>Tipi di Nodo Differenti <a class="hash-link" href="#tipi-di-nodo-differenti">#</a></h3>
<p>Se il tipo di nodo è differente, React li tratterà come due sottoalberi diversi, getterà via il primo e costruirà e inserirà il secondo.</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml">renderA: <span class="nt">&lt;div</span> <span class="nt">/&gt;</span>
renderB: <span class="nt">&lt;span</span> <span class="nt">/&gt;</span>
=&gt; [removeNode <span class="nt">&lt;div</span> <span class="nt">/&gt;</span>], [insertNode <span class="nt">&lt;span</span> <span class="nt">/&gt;</span>]
</code></pre></div>
<p>La stessa logica è usata per i componenti personalizzati. Se non sono dello stesso tipo, React non proverà neppure a confrontare ciò che visualizzano. Rimuoverà soltanto il primo dal DOM e inserirà il secondo.</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml">renderA: <span class="nt">&lt;Header</span> <span class="nt">/&gt;</span>
renderB: <span class="nt">&lt;Content</span> <span class="nt">/&gt;</span>
=&gt; [removeNode <span class="nt">&lt;Header</span> <span class="nt">/&gt;</span>], [insertNode <span class="nt">&lt;Content</span> <span class="nt">/&gt;</span>]
</code></pre></div>
<p>Possedere questa conoscenza di alto livello è un aspetto molto importante del perché l&#39;algoritmo di differenza di React è sia veloce che preciso. Ciò fornisce una buona euristica per potare rapidamente gran parte dell&#39;albero e concentrarsi su parti che hanno una buona probabilità di essere simili.</p>

<p>È molto improbabile che un elemento <code>&lt;Header&gt;</code> generi un DOM che somigli a quello generato da un elemento <code>&lt;Content&gt;</code>. Anziché perdere tempo provando a confrontare queste due strutture, React semplicemente ricostruisce l&#39;albero da zero.</p>

<p>Come corollario, se c&#39;è un elemento <code>&lt;Header&gt;</code> nella stessa posizione in due rendering consecutivi, ti puoi aspettare di trovare una struttura molto simile che vale la pena di esplorare.</p>
<h3><a class="anchor" name="nodi-dom"></a>Nodi DOM <a class="hash-link" href="#nodi-dom">#</a></h3>
<p>Quando vengono confrontati nodi DOM, guardiamo gli attributi di entrambi e decidiamo quali di essi sono cambiati in un tempo lineare.</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml">renderA: <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;before&quot;</span> <span class="nt">/&gt;</span>
renderB: <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;after&quot;</span> <span class="nt">/&gt;</span>
=&gt; [replaceAttribute id &quot;after&quot;]
</code></pre></div>
<p>Anziché trattare lo stile come una stringa opaca, viene rappresentato come un oggetto chiave-valore. Ciò ci permette di aggiornare solo le proprietà che sono cambiate.</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml">renderA: <span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">{{color:</span> <span class="err">&#39;red&#39;}}</span> <span class="nt">/&gt;</span>
renderB: <span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">{{fontWeight:</span> <span class="err">&#39;bold&#39;}}</span> <span class="nt">/&gt;</span>
=&gt; [removeStyle color], [addStyle font-weight &#39;bold&#39;]
</code></pre></div>
<p>Dopo che gli attributi sono stati aggiornati, effettuiamo un confronto ricorsivo su ciascuno dei nodi figli.</p>
<h3><a class="anchor" name="componenti-personalizzati"></a>Componenti Personalizzati <a class="hash-link" href="#componenti-personalizzati">#</a></h3>
<p>We decided that the two custom components are the same. Since components are stateful, we cannot just use the new component and call it a day. React takes all the attributes from the new component and calls <code>component[Will/Did]ReceiveProps()</code> on the previous one.</p>

<p>The previous component is now operational. Its <code>render()</code> method is called and the diff algorithm restarts with the new result and the previous result.</p>
<h2><a class="anchor" name="list-wise-diff"></a>List-wise diff <a class="hash-link" href="#list-wise-diff">#</a></h2><h3><a class="anchor" name="problematic-case"></a>Problematic Case <a class="hash-link" href="#problematic-case">#</a></h3>
<p>In order to do children reconciliation, React adopts a very naive approach. It goes over both lists of children at the same time and generates a mutation whenever there&#39;s a difference.</p>

<p>For example if you add an element at the end:</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml">renderA: <span class="nt">&lt;div&gt;&lt;span&gt;</span>first<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
renderB: <span class="nt">&lt;div&gt;&lt;span&gt;</span>first<span class="nt">&lt;/span&gt;&lt;span&gt;</span>second<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
=&gt; [insertNode <span class="nt">&lt;span&gt;</span>second<span class="nt">&lt;/span&gt;</span>]
</code></pre></div>
<p>Inserting an element at the beginning is problematic. React is going to see that both nodes are spans and therefore run into a mutation mode.</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml">renderA: <span class="nt">&lt;div&gt;&lt;span&gt;</span>first<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
renderB: <span class="nt">&lt;div&gt;&lt;span&gt;</span>second<span class="nt">&lt;/span&gt;&lt;span&gt;</span>first<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
=&gt; [replaceAttribute textContent &#39;second&#39;], [insertNode <span class="nt">&lt;span&gt;</span>first<span class="nt">&lt;/span&gt;</span>]
</code></pre></div>
<p>There are many algorithms that attempt to find the minimum sets of operations to transform a list of elements. <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> can find the minimum using single element insertion, deletion and substitution in O(n<sup>2</sup>). Even if we were to use Levenshtein, this doesn&#39;t find when a node has moved into another position and algorithms to do that have much worse complexity.</p>
<h3><a class="anchor" name="keys"></a>Keys <a class="hash-link" href="#keys">#</a></h3>
<p>In order to solve this seemingly intractable issue, an optional attribute has been introduced. You can provide for each child a key that is going to be used to do the matching. If you specify a key, React is now able to find insertion, deletion, substitution and moves in O(n) using a hash table.</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml">renderA: <span class="nt">&lt;div&gt;&lt;span</span> <span class="na">key=</span><span class="s">&quot;first&quot;</span><span class="nt">&gt;</span>first<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
renderB: <span class="nt">&lt;div&gt;&lt;span</span> <span class="na">key=</span><span class="s">&quot;second&quot;</span><span class="nt">&gt;</span>second<span class="nt">&lt;/span&gt;&lt;span</span> <span class="na">key=</span><span class="s">&quot;first&quot;</span><span class="nt">&gt;</span>first<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
=&gt; [insertNode <span class="nt">&lt;span&gt;</span>second<span class="nt">&lt;/span&gt;</span>]
</code></pre></div>
<p>In practice, finding a key is not really hard. Most of the time, the element you are going to display already has a unique id. When that&#39;s not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. Remember that the key only has to be unique among its siblings, not globally unique.</p>
<h2><a class="anchor" name="trade-offs"></a>Trade-offs <a class="hash-link" href="#trade-offs">#</a></h2>
<p>It is important to remember that the reconciliation algorithm is an implementation detail. React could re-render the whole app on every action; the end result would be the same. We are regularly refining the heuristics in order to make common use cases faster.</p>

<p>In the current implementation, you can express the fact that a sub-tree has been moved amongst its siblings, but you cannot tell that it has moved somewhere else. The algorithm will re-render that full sub-tree.</p>

<p>Because we rely on two heuristics, if the assumptions behind them are not met, performance will suffer.</p>

<ol>
<li><p>The algorithm will not try to match sub-trees of different components classes. If you see yourself alternating between two components classes with very similar output, you may want to make it the same class. In practice, we haven&#39;t found this to be an issue.</p></li>
<li><p>If you don&#39;t provide stable keys (by using Math.random() for example), all the sub-trees are going to be re-rendered every single time. By giving the users the choice to choose the key, they have the ability to shoot themselves in the foot.</p></li>
</ol>


    <div class="docs-prevnext">
      
        <a class="docs-prev" href="/react/docs/special-non-dom-attributes-it-IT.html">&larr; Prev</a>
      
      
        <a class="docs-next" href="/react/docs/webcomponents.html">Next &rarr;</a>
      
    </div>
  </div>
</section>


    <footer class="wrap">
      <div class="left">
        A Facebook &amp; Instagram collaboration.<br>
        <a href="/react/acknowledgements.html">Acknowledgements</a>
      </div>
      <div class="right">
        &copy; 2013&ndash;2015 Facebook Inc.<br>
        Documentation licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
      </div>
    </footer>
  </div>
  <div id="fb-root"></div>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-41298772-1', 'facebook.github.io');
    ga('send', 'pageview');

    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");

    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=623268441017527";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
  </script>
</body>
</html>
